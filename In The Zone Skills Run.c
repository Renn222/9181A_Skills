#pragma config(Sensor, in4,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  QEBase,         sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port1,           claw,          tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           baseLiftR,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           coneLiftY,     tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           FRWheel,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           BRWheel,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           FLWheel,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           BLWheel,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           coneLiftRL,    tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           coneLiftLL,    tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          baseLiftL,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"
//Initialization
//float robotDiameter = 22;//front right wheel to back left wheel
//chassis
int reverseChassis = 1;
bool iGaveUpNaming = false;

/*
float x = 0.0;
float y = 0.0;
bool front = true;
bool right = true;
float xPercent = 0.0;
float yPercent = 0.0;
float motorSpdRight = 0.0;
float motorSpdLeft = 0.0;
*/
//TEST (DELETE ALL VAR UNDER THIS LATER)

int sensorREChassis = 0;
int sensorQEBase = 0;
int sensorLEChassis = 0;
int sensorGyroscope = 0;


//cone lift
float maxMotorSpd = 121.0;
int yellowArk = 0;
bool holdLiftUp = false;
//base lift (2nd controller)
int baseArk = 0;
int baseArkMod = 0;
//claw
float clawSpd = 90;
//alto
bool reset = true;

//int gyr = 0;

#define TURN_SLOWDOWN 10

//KILL BUTTON/////////////////////////////////////////////////////////////////////////////////////////
void kill(){
	motor[port1] = 0;
	//motor[port2] = 0; cant kill base lift cuz it needs to be held up
	//motor[port3] = 0; cant kill cone lift cuz it needs to be held up
	motor[port4] = 0;
	motor[port5] = 0;
	motor[port6] = 0;
	motor[port7] = 0;
	//motor[port8] = 0; cone lift
	//motor[port9] = 0; cone lift
	//motor[port10] = 0; base lift
	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;
	SensorValue[QEBase] = 0;
	//resetSensor(Gyro);
	//resetSensor(QEBase);
	//resetMotorEncoder(SensorValue[rightEncoder]);
	//resetMotorEncoder(SensorValue[leftEncoder]);
	wait1Msec(500);
}

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	SensorType[gyro] = sensorNone;
	wait1Msec(500);
	SensorType[gyro] = sensorGyro;
	wait1Msec(1100);// can not be less than 1100
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

/* Methods for altonomous */

void driveAlto(float distanceInInches, int spd)//distance controls direction not spd
{
	float leftSpd = spd;
	float rightSpd = spd;
	float inverter = -1;
	if(distanceInInches < 0.0)
	{
		inverter*=-1;
	}
	float wheelRadius = 2.0;
	float cir = wheelRadius*2*PI;
	//float radian = distanceInInches/wheelRadius;
	float degree = ((distanceInInches/cir) * 360);

	//resetMotorEncoder(SensorValue[rightEncoder]);//This is how to CORRECTLY reset integrated motor encoders
	//resetMotorEncoder(SensorValue[leftEncoder]);
	//wait1Msec(200);
	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;
	while(abs(degree) > abs(SensorValue[rightEncoder]) && abs(degree) > abs(SensorValue[leftEncoder]))
	{
		rightSpd = spd;
		leftSpd = spd;
		//uhhhhh idk if this works but whatever
		if(leftSpd > 125.0){
			leftSpd = 125.0;
		}
		else if(leftSpd < -125.0)
		{
			leftSpd = -125.0;
		}
		if(rightSpd > 125.0){
			rightSpd = 125.0;
		}
		else if(rightSpd < -125.0)
		{
			rightSpd = -125.0;
		}
		motor[BLWheel] = leftSpd * inverter;
		motor[BRWheel] = rightSpd * inverter;
		motor[FLWheel] = leftSpd * inverter;
		motor[FRWheel] = rightSpd * inverter;
	}
	motor[BLWheel] = -(leftSpd * inverter) / 20;
	motor[BRWheel] = -(rightSpd * inverter) / 20;
	motor[FLWheel] = -(leftSpd * inverter) / 20;
	motor[FRWheel] = -(rightSpd * inverter) / 20;
	wait1Msec(100);
	motor[BLWheel] = 0;
	motor[BRWheel] = 0;
	motor[FLWheel] = 0;
	motor[FRWheel] = 0;
}

void liftUpHold()
{
	int liftSpd = 110;// assumes positive is away from base cone
	int liftHold = 16;
	motor[claw] = 20;
	motor[coneLiftLL] = liftSpd;
	motor[coneLiftRL] = liftSpd;
	motor[coneLiftY] = liftSpd;
	wait1Msec(350);
	motor[coneLiftLL] = liftHold;
	motor[coneLiftRL] = liftHold;
	motor[coneLiftY] = liftHold;
}
void liftDownUpHold()
{
	int liftSpd = 110;// assumes positive is away from base cone
	int liftHold = 16;
	motor[coneLiftLL] = -20;
	motor[coneLiftRL] = -20;
	motor[coneLiftY] = -20;
	wait1Msec(200);
	motor[claw] = -clawSpd;
	wait1Msec(220);
	motor[claw] = 0;
	wait1Msec(200);
	motor[coneLiftLL] = liftSpd;
	motor[coneLiftRL] = liftSpd;
	motor[coneLiftY] = liftSpd;
	wait1Msec(350);
	motor[coneLiftLL] = liftHold;
	motor[coneLiftRL] = liftHold;
	motor[coneLiftY] = liftHold;
}

void baseDown(){
	if(reset)
	{
		SensorValue[QEBase] = 0;
	}
	else
	{
		reset = true;
	}
	while(abs(SensorValue[QEBase])<890){
		motor[baseLiftL] = 121;
		motor[baseLiftR] = 121;
	}
	motor[baseLiftL] = 0;
	motor[baseLiftR] = 0;
}

void baseUp(){
	SensorValue[QEBase] = 0;
	while(abs(SensorValue[QEBase])<890){
		motor[baseLiftL] = -121;
		motor[baseLiftR] = -121;
	}
	motor[baseLiftL] = -12;
	motor[baseLiftR] = -12;
}

void pickUpBase(){
	baseDown();
	driveAlto(10.0, 90);
	wait1Msec(200);
	baseUp();
	driveAlto(-10.0, 90);
}

void putDownBase(){
	baseDown();
	driveAlto(-5.0, 100);
	baseUp();
}

void turnToBearing(int bearing)//assume positive is right and negative is left
{
	//bearing*=(4/5);
	bearing = (bearing / 10) * 9;
	int currentBearing = SensorValue[gyro]/10;
	int targetBearing = bearing + currentBearing;
	//float gyr = SensorValue[Gyro]/10;


	//MAKE TURNING ACCURATE BY MAKING REVERSE FOR 80ms


	if (targetBearing < SensorValue[gyro]/10) // Left turn
	{
		while (SensorValue[gyro]/10 > targetBearing + TURN_SLOWDOWN)
		{
			motor[FLWheel] = 100;
			motor[FRWheel] = -100;
			motor[BLWheel] = 100;
			motor[BRWheel] = -100;
			//gyr = SensorValue[Gyro]/10;
		}
		while (SensorValue[gyro]/10 > targetBearing)
		{
			motor[FLWheel] = 50;
			motor[FRWheel] = -50;
			motor[BLWheel] = 50;
			motor[BRWheel] = -50;
			//gyr = SensorValue[Gyro]/10;
		}

		motor[FLWheel] = -50;
		motor[FRWheel] = 50;
		motor[BLWheel] = -50;
		motor[BRWheel] = 50;

		wait1Msec(100);

		motor[FLWheel] = 0;
		motor[FRWheel] = 0;
		motor[BLWheel] = 0;
		motor[BRWheel] = 0;
	}
	else // Right turn
	{
		while (SensorValue[gyro]/10 < targetBearing - TURN_SLOWDOWN)
		{
			motor[FLWheel] = -100;
			motor[FRWheel] = 100;
			motor[BLWheel] = -100;
			motor[BRWheel] = 100;
			//gyr = SensorValue[Gyro]/10;
		}
		while (SensorValue[gyro]/10 < targetBearing)
		{
			motor[FLWheel] = -50;
			motor[FRWheel] = 50;
			motor[BLWheel] = -50;
			motor[BRWheel] = 50;
			//gyr = SensorValue[gyro]/10;
		}
		motor[FLWheel] = 50;
		motor[FRWheel] = -50;
		motor[BLWheel] = 50;
		motor[BRWheel] = -50;

		wait1Msec(100);

		motor[FLWheel] = 0;
		motor[FRWheel] = 0;
		motor[BLWheel] = 0;
		motor[BRWheel] = 0;
	}
}



task autonomous()
{
	/*

	*/
	//SensorFullCount[Gyro] = 3600;

	//test
	//driveAlto(10, 120);//forward 10 inches at 120/127 spd
	//wait1Msec(2000);
	//driveAlto(50, 120);
	//driveAlto(-10, 120);//backward 10 inches at 120/127 spd

	//turnToBearing(180);//turn right 180 degrees

	//wait1Msec(2000);

	//turnToBearing(180);//turn left 180 degrees

	//liftUpHold();

	//wait1Msec(2000);

	//liftDownUpHold();

	//pickUpBase();

	//putDownBase();


	//PASSED THE TEST ^



	//mat size 12' by 12'
	//mat diameter ~17
	int baseSpd = 120;

	liftUpHold();
	baseDown();
	driveAlto(40, 120);//(distance, spd)
	baseUp();
	wait1Msec(200);
	liftDownUpHold();
	driveAlto(-31, 110);
	turnToBearing(-45);//degree of turn
	driveAlto(-17, 110);
	turnToBearing(-90);
	driveAlto(-4, 110);
	wait1Msec(200);
	driveAlto(28, 125);
	putDownBase();//score 22 points
	//total 22

	driveAlto(-20, 125);
	turnToBearing(-80);//wall crash
	driveAlto(-17, 90);//wall
	turnToBearing(-10);//wall
	driveAlto(-20, 90);//wall
	kill(); //wall sensor reset
	baseDown();
	driveAlto(18, 100);//(distance, spd)
	baseUp();
	turnToBearing(133);
	driveAlto(22, 100);
	putDownBase();//score 10 points
	//total 32

	turnToBearing(-90);
	driveAlto(19, 100);
	turnToBearing(-90);
	baseDown();
	driveAlto(18, 120);
	baseUp();
	SensorType[gyro] = sensorNone;
	wait1Msec(500);
	SensorType[gyro] = sensorGyro;
	wait1Msec(1100);// can not be less than 1100
	turnToBearing(-180);
	driveAlto(16, 100);
	putDownBase();//score 10 points
	//total 42

	turnToBearing(-180);
	SensorValue[QEBase] = 0;
	motor[baseLiftL] = baseSpd;
	motor[baseLiftR] = baseSpd;
	driveAlto(30, 100);//(distance, spd)
	reset = false;
	pickUpBase();
	driveAlto(16, 100);
	turnToBearing(-90);
	driveAlto(9, 80);
	turnToBearing(90);
	driveAlto(20, 120);
	putDownBase();//score 20 points
	driveAlto(-20, 120);
	//total 62

	turnToBearing(-90);
	driveAlto(8, 110);
	turnToBearing(-90);
	SensorValue[QEBase] = 0;
	motor[baseLiftL] = baseSpd;
	motor[baseLiftR] = baseSpd;
	driveAlto(15, 100);//(distance, spd)
	reset = false;
	pickUpBase();
	turnToBearing(180);
	driveAlto(15, 100);
	putDownBase();
	//total 72

	//If there is time then move on to this code \/

	turnToBearing(-90);
	driveAlto(16, 120);//crash into wall here
	driveAlto(-3, 100);//needs to be fine tuned for the wall
	turnToBearing(-45);
	SensorValue[QEBase] = 0;
	motor[baseLiftL] = baseSpd;
	motor[baseLiftR] = baseSpd;
	driveAlto(28, 100);//(distance, spd)
	reset = false;
	pickUpBase();
	wait1Msec(200);
	driveAlto(-23, 110);
	turnToBearing(-45);//degree of turn
	driveAlto(-10, 110);
	turnToBearing(-90);
	driveAlto(10, 125);
	putDownBase();//score 10 points
	//total 82
}
/*
Sequence:

yellow cone raise
forward
base cone pick up
yellow cone place and raise lift
backward
turn left
backward
tu rn left
forward
base cone place (score 22 points)

total: 22

backward
turn right -> replace with wall crashing
forward -> replace
turn right -> replace
forward
base cone pick up
turn around
forward
base cone place (score 10 points)

total: 32

turn left
forward
turn left
forward
base cone pickup
turn around
forward
base cone place (score 10 points)

total: 42

turn around
forward
base cone pickup
forward
turn left
forward
turn right
forward
base cone place (score 20 points)

total: 62

backward
turn left
forward
turn left
forward
base cone pickup
turn around
base cone place (score 10 points)

total: 72

\/ maybe if there is time \/

backward
turn left
forward
turn left
forward
base cone pickup
backward
turn left
forward
turn left
forward
base cone place (score 5 or 10 points)

total: 77 or 82

*/
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
task usercontrol()
{
	while (true)
	{
		//TEST
		sensorREChassis = SensorValue[rightEncoder];
		sensorQEBase = SensorValue[QEBase];
		sensorLEChassis = SensorValue[leftEncoder];
		sensorGyroscope = SensorValue[gyro];
		//2500 max open
		//1700 clamp cone
		//chassis//////////////////////////////////////////////////////////////////////////////////////////

		if(iGaveUpNaming && (vexRT[Btn8R]==1)){
			reverseChassis*=-1;
			iGaveUpNaming = false;
		}
		else if(!iGaveUpNaming && (vexRT[Btn8L]==1)){
			reverseChassis*=-1;
			iGaveUpNaming = true;
		}
		if(vexRT[Ch2] > 5 || vexRT[Ch1] < -5 || vexRT[Ch2] > 5 || vexRT[Ch2] < -5){
			motor[FRWheel] = -(reverseChassis*vexRT[Ch2] - vexRT[Ch1]);
			motor[FLWheel] = -(reverseChassis*vexRT[Ch2] + vexRT[Ch1]);
			motor[BRWheel] = -(reverseChassis*vexRT[Ch2] - vexRT[Ch1]);
			motor[BLWheel] = -(reverseChassis*vexRT[Ch2] + vexRT[Ch1]);
		}
		else
		{
			motor[FRWheel] = 0;
			motor[FLWheel] = 0;
			motor[BRWheel] = 0;
			motor[BLWheel] = 0;
		}

		//lift yellow cone/////////////////////////////////////////////////////////////////////////////////////////////////////////

		yellowArk = vexRT[Ch3Xmtr2];
		if(vexRT[Btn8UXmtr2] == 1)
		{
			holdLiftUp = true;
		}
		if(yellowArk < 5 && yellowArk >- 5){
			yellowArk = 0;
		}
		if(yellowArk>5 || yellowArk < -5)
		{
			holdLiftUp = false;
		}
		if(yellowArk > maxMotorSpd){
			yellowArk = maxMotorSpd;
		}
		else if(yellowArk < -maxMotorSpd){
			yellowArk = -maxMotorSpd;
		}
		if(holdLiftUp)
		{
			yellowArk = 20;
		}
		if(yellowArk == 0){
			motor[port3] = 0;//change this later so it balances the lift at a location
			motor[port8] = 0;
			motor[port9] = 0;
		}
		else{
			motor[port3] = yellowArk;//Invert this if need be
			motor[port8] = yellowArk;
			motor[port9] = yellowArk;
		}


		//lift base cone//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		if(vexRT[Btn8D] == 1) {
			baseArkMod = -12;
		}
		baseArk = vexRT[Ch3];
		if(baseArk < 5 && baseArk > -5){
			baseArk = 0;
		}
		else {
			baseArkMod = 0;
		}
		if(baseArk > maxMotorSpd){
			baseArk = maxMotorSpd;
		}
		else if(baseArk < -maxMotorSpd){
			baseArk = -maxMotorSpd;
		}
		if(baseArk == 0){
			motor[port2] = baseArkMod;//change this later so it balances the lift at a location
			motor[port10] = baseArkMod;
		}
		else{
			motor[port2] = baseArk;//Invert this if need be
			motor[port10] = baseArk;
		}

		//claw/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		if(vexRT[Btn6U]==1 || vexRT[Btn6UXmtr2]==1){
			motor[port1] = clawSpd;
			} else if(vexRT[Btn6D]==1 || vexRT[Btn6DXmtr2]==1){
			motor[port1] = -clawSpd;
			} else {
			motor[port1] = 0;
		}

		//kill button
		if(vexRT[Btn7L] == 1 || vexRT[Btn7LXmtr2] == 1){
			kill();
		}
	}
}
/*
How shit works:

button 7L is kill - press to explode

Yellow cone lift - cone lift
Base cone lift   - base lift

main controller:
ch3 - base lift
ch1 -\
chassis
ch2 -/
6U - open claw
6D - close claw
8R -\
reverse the chassis
8L -/
8D - holds base lift in place
2nd controller:
ch3 - cone lift
6U - open claw
6D - close claw
8U - holds cone lift up
*/
